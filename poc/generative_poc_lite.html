<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Shader Layout POC — Lite (Pi optimized)</title>
<style>
  * { margin: 0; padding: 0; }
  body { background: #000; overflow: hidden; }
  canvas { display: block; width: 100vw; height: 100vh; image-rendering: auto; }
  #stats {
    position: fixed; top: 8px; left: 8px;
    color: #0f0; font: 14px monospace;
    background: rgba(0,0,0,0.7); padding: 4px 8px;
    z-index: 10; pointer-events: none;
  }
</style>
</head>
<body>
<div id="stats">FPS: --</div>
<canvas id="c"></canvas>
<script>
// ── 2D generative shader — NO raymarching, cheap per-pixel math ──
const FRAG = `
precision mediump float;

uniform float iTime;
uniform vec2  iResolution;
uniform float uSensorA;
uniform float uSensorB;
uniform float uSensorC;

// Simple hash — one instruction
float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

// Value noise — 4 texture lookups equivalent
float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);
    return mix(
        mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
        mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x),
        f.y
    );
}

// 3-octave FBM (not 5)
float fbm(vec2 p) {
    float v = 0.0;
    float a = 0.5;
    mat2 rot = mat2(0.87, 0.48, -0.48, 0.87);
    for (int i = 0; i < 3; i++) {
        v += a * noise(p);
        p = rot * p * 2.0;
        a *= 0.5;
    }
    return v;
}

void main() {
    vec2 uv = gl_FragCoord.xy / iResolution.xy;
    float t = iTime * (0.3 + uSensorA * 0.4);

    // Warp UV with sensor-driven distortion
    vec2 q = vec2(fbm(uv * 3.0 + t * 0.2), fbm(uv * 3.0 + vec2(1.7, 9.2) + t * 0.15));
    vec2 r = vec2(fbm(uv * 2.0 + q + vec2(8.3, 2.8) + t * 0.1), fbm(uv * 2.0 + q + vec2(5.1, 3.3) + t * 0.12));

    float f = fbm(uv * 1.5 + r * (1.0 + uSensorB));

    // Color palette — shifts with sensors
    vec3 col = mix(vec3(0.05, 0.02, 0.15), vec3(0.6, 0.1, 0.3), f);
    col = mix(col, vec3(0.1, 0.4, 0.8), r.x * 0.8);
    col = mix(col, vec3(0.9, 0.5, 0.1), r.y * r.y * 0.6);

    // Pulse ring driven by sensorC
    float d = length(uv - 0.5) * 2.0;
    float ring = smoothstep(0.02, 0.0, abs(d - fract(t * 0.5) * (1.0 + uSensorC)) * 3.0);
    col += vec3(0.3, 0.6, 1.0) * ring * 0.5;

    // Slight vignette
    vec2 vig = uv * (1.0 - uv);
    col *= pow(vig.x * vig.y * 16.0, 0.2);

    gl_FragColor = vec4(col, 1.0);
}
`;

const VERT = `
attribute vec2 pos;
void main() { gl_Position = vec4(pos, 0.0, 1.0); }
`;

const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', { antialias: false, alpha: false });
const statsEl = document.getElementById('stats');

// Render at HALF native resolution — CSS scales it up
function resize() {
    const scale = 0.5; // <-- resolution scale factor
    canvas.width  = Math.floor(window.innerWidth  * scale);
    canvas.height = Math.floor(window.innerHeight * scale);
    gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

function compile(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        const err = gl.getShaderInfoLog(s);
        console.error(err);
        statsEl.textContent = 'SHADER ERROR: ' + err;
    }
    return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, VERT));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, FRAG));
gl.linkProgram(prog);
if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
    statsEl.textContent = 'LINK ERROR: ' + gl.getProgramInfoLog(prog);
}
gl.useProgram(prog);

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
const posLoc = gl.getAttribLocation(prog, 'pos');
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

const uTime = gl.getUniformLocation(prog, 'iTime');
const uRes  = gl.getUniformLocation(prog, 'iResolution');
const uA    = gl.getUniformLocation(prog, 'uSensorA');
const uB    = gl.getUniformLocation(prog, 'uSensorB');
const uC    = gl.getUniformLocation(prog, 'uSensorC');

const gpuRenderer = gl.getParameter(gl.RENDERER) || 'unknown';
let frames = 0, lastFps = 0, lastTime = performance.now();

function fakeSensor(t, offset) {
    return 0.5 + 0.5 * Math.sin(t * 0.001 + offset);
}

const start = performance.now();
function frame(now) {
    const t = (now - start) / 1000.0;

    gl.uniform1f(uTime, t);
    gl.uniform2f(uRes, canvas.width, canvas.height);
    gl.uniform1f(uA, fakeSensor(now, 0));
    gl.uniform1f(uB, fakeSensor(now, 2));
    gl.uniform1f(uC, fakeSensor(now, 4));

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    frames++;
    if (now - lastTime >= 1000) {
        lastFps = frames;
        frames = 0;
        lastTime = now;
        statsEl.textContent = `FPS: ${lastFps}  |  ${canvas.width}x${canvas.height}  |  GPU: ${gpuRenderer}`;
    }

    requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
